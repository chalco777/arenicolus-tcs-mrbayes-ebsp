# GG

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 

library(knitr)
```
```{r}
library(ape)
library(pegas)
library(readr)
library(dplyr)
``` 

# Load alignment

```{r}
aln <- read.dna("../results/phylogenetic_analysis/ml/mtDNA_concat.fasta", format="fasta")
rownames(aln) <- gsub("_", "", rownames(aln))
nrow(aln)
ncol(aln)
rownames(aln)[1:5]
```


```{r}
# 2) Carga el mapeo muestra→región (del paso A) y sincroniza orden
map <- read_tsv("../data/sample_to_region_mtDNA.tsv", show_col_types = FALSE)
map |> select(count) |> summarise(conteo=sum(count))
map |> filter(is.na(count))


```

```{R}
map <- read_tsv("../data/sample_to_region_mtDNA_completed.tsv", show_col_types = FALSE)
map |> select(count) |> summarise(conteo=sum(count))
map |> filter(is.na(count))


```
# Mantén sólo las muestras que están tanto en el alineamiento como en el mapeo
keep <- intersect(rownames(aln), map$sample)
aln   <- aln[keep, ]
map   <- map %>% filter(sample %in% keep)

# Asegura el mismo orden entre 'aln' y 'map'
map   <- map[ match(rownames(aln), map$sample), ]
stopifnot(all(rownames(aln) == map$sample))
Region <- factor(map$region)
table(Region)

# 3) Estadísticos globales
```{r}
S_global  <- length(seg.sites(aln))            # sitios segregantes (S)
pi_global <- nuc.div(aln)                      # diversidad nucleotídica (π)
L_global  <- ncol(aln)                         # longitud del alineamiento
k_global  <- pi_global * L_global              # diferencias promedio por par (k)
haps      <- haplotype(aln)                    # haplotipos únicos
nH_global <- nrow(haps)                        # número de haplotipos
Hd_global <- hap.div(aln, variance = TRUE)     # diversidad haplotípica (Hd) (+ var.)

S_global
pi_global
k_global
nH_global
Hd_global
```
# 4) Estadísticos por región (índices por nivel de factor)
idx_by_reg <- split(seq_len(nrow(aln)), Region)

S_by_reg <- sapply(idx_by_reg, function(ix) length(seg.sites(aln[ix, ])))
nH_by_reg <- sapply(idx_by_reg, function(ix) nrow(haplotype(aln[ix, ])))
Hd_by_reg <- sapply(idx_by_reg, function(ix) hap.div(aln[ix, ]))
pi_by_reg <- sapply(idx_by_reg, function(ix) nuc.div(aln[ix, ]))
k_by_reg  <- pi_by_reg * ncol(aln)    # k = π * L (L común del alineamiento)

# 5) Consolida resultados en tablas y guarda a disco
tab_global <- data.frame(
  scope = "GLOBAL",
  S = S_global,
  pi = pi_global,
  k  = k_global,
  n_haplotypes = nH_global,
  Hd = Hd_global[1],                   # valor
  Hd_var = Hd_global[2]                # varianza
)

tab_by_reg <- data.frame(
  region = names(S_by_reg),
  S = as.integer(S_by_reg),
  pi = as.numeric(pi_by_reg),
  k  = as.numeric(k_by_reg),
  n_haplotypes = as.integer(nH_by_reg),
  Hd = as.numeric(Hd_by_reg)
)

write.csv(tab_global, "mtDNA_stats_global.csv", row.names = FALSE)
write.csv(tab_by_reg, "mtDNA_stats_by_region.csv", row.names = FALSE)

tab_global
tab_by_reg